{"ast":null,"code":"import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport * as React from 'react';\nimport * as ReactDOM from 'react-dom';\nimport { unstable_useEnhancedEffect as useEnhancedEffect, unstable_useEventCallback as useEventCallback } from '@mui/utils';\nimport useLazyRef from '@mui/utils/useLazyRef';\nimport useTimeout from '@mui/utils/useTimeout';\nimport { useRtl } from '@mui/system/RtlProvider';\nimport reactMajor from '@mui/x-internals/reactMajor';\nimport { useGridPrivateApiContext } from \"../../utils/useGridPrivateApiContext.js\";\nimport { useGridRootProps } from \"../../utils/useGridRootProps.js\";\nimport { useGridSelector } from \"../../utils/useGridSelector.js\";\nimport { useRunOnce } from \"../../utils/useRunOnce.js\";\nimport { gridVisibleColumnDefinitionsSelector, gridVisiblePinnedColumnDefinitionsSelector, gridColumnPositionsSelector, gridHasColSpanSelector } from \"../columns/gridColumnsSelector.js\";\nimport { gridDimensionsSelector } from \"../dimensions/gridDimensionsSelectors.js\";\nimport { gridPinnedRowsSelector } from \"../rows/gridRowsSelector.js\";\nimport { gridFocusCellSelector, gridTabIndexCellSelector } from \"../focus/gridFocusStateSelector.js\";\nimport { useGridVisibleRows, getVisibleRows } from \"../../utils/useGridVisibleRows.js\";\nimport { useGridApiEventHandler } from \"../../utils/index.js\";\nimport * as platform from \"../../../utils/platform.js\";\nimport { clamp, range } from \"../../../utils/utils.js\";\nimport { selectedIdsLookupSelector } from \"../rowSelection/gridRowSelectionSelector.js\";\nimport { gridRowsMetaSelector } from \"../rows/gridRowsMetaSelector.js\";\nimport { getFirstNonSpannedColumnToRender } from \"../columns/gridColumnsUtils.js\";\nimport { gridRenderContextSelector, gridVirtualizationRowEnabledSelector, gridVirtualizationColumnEnabledSelector } from \"./gridVirtualizationSelectors.js\";\nimport { EMPTY_RENDER_CONTEXT } from \"./useGridVirtualization.js\";\nimport { gridRowSpanningHiddenCellsOriginMapSelector } from \"../rows/gridRowSpanningSelectors.js\";\nimport { gridListColumnSelector } from \"../listView/gridListViewSelectors.js\";\nimport { minimalContentHeight } from \"../rows/gridRowsUtils.js\";\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nconst MINIMUM_COLUMN_WIDTH = 50;\nvar ScrollDirection = /*#__PURE__*/function (ScrollDirection) {\n  ScrollDirection[ScrollDirection[\"NONE\"] = 0] = \"NONE\";\n  ScrollDirection[ScrollDirection[\"UP\"] = 1] = \"UP\";\n  ScrollDirection[ScrollDirection[\"DOWN\"] = 2] = \"DOWN\";\n  ScrollDirection[ScrollDirection[\"LEFT\"] = 3] = \"LEFT\";\n  ScrollDirection[ScrollDirection[\"RIGHT\"] = 4] = \"RIGHT\";\n  return ScrollDirection;\n}(ScrollDirection || {});\nconst EMPTY_SCROLL_POSITION = {\n  top: 0,\n  left: 0\n};\nexport const EMPTY_DETAIL_PANELS = Object.freeze(new Map());\nconst createScrollCache = (isRtl, rowBufferPx, columnBufferPx, verticalBuffer, horizontalBuffer) => ({\n  direction: ScrollDirection.NONE,\n  buffer: bufferForDirection(isRtl, ScrollDirection.NONE, rowBufferPx, columnBufferPx, verticalBuffer, horizontalBuffer)\n});\nlet isJSDOM = false;\ntry {\n  if (typeof window !== 'undefined') {\n    isJSDOM = /jsdom|HappyDOM/.test(window.navigator.userAgent);\n  }\n} catch (_) {\n  /* ignore */\n}\nexport const useGridVirtualScroller = () => {\n  const apiRef = useGridPrivateApiContext();\n  const rootProps = useGridRootProps();\n  const {\n    unstable_listView: listView\n  } = rootProps;\n  const visibleColumns = useGridSelector(apiRef, () => listView ? [gridListColumnSelector(apiRef.current.state)] : gridVisibleColumnDefinitionsSelector(apiRef));\n  const enabledForRows = useGridSelector(apiRef, gridVirtualizationRowEnabledSelector) && !isJSDOM;\n  const enabledForColumns = useGridSelector(apiRef, gridVirtualizationColumnEnabledSelector) && !isJSDOM;\n  const dimensions = useGridSelector(apiRef, gridDimensionsSelector);\n  const outerSize = dimensions.viewportOuterSize;\n  const pinnedRows = useGridSelector(apiRef, gridPinnedRowsSelector);\n  const pinnedColumnDefinitions = useGridSelector(apiRef, gridVisiblePinnedColumnDefinitionsSelector);\n  const pinnedColumns = listView ? {\n    left: [],\n    right: []\n  } : pinnedColumnDefinitions;\n  const hasBottomPinnedRows = pinnedRows.bottom.length > 0;\n  const [panels, setPanels] = React.useState(EMPTY_DETAIL_PANELS);\n  const isRtl = useRtl();\n  const cellFocus = useGridSelector(apiRef, gridFocusCellSelector);\n  const cellTabIndex = useGridSelector(apiRef, gridTabIndexCellSelector);\n  const rowsMeta = useGridSelector(apiRef, gridRowsMetaSelector);\n  const selectedRowsLookup = useGridSelector(apiRef, selectedIdsLookupSelector);\n  const currentPage = useGridVisibleRows(apiRef, rootProps);\n  const gridRootRef = apiRef.current.rootElementRef;\n  const mainRef = apiRef.current.mainElementRef;\n  const scrollerRef = apiRef.current.virtualScrollerRef;\n  const scrollbarVerticalRef = apiRef.current.virtualScrollbarVerticalRef;\n  const scrollbarHorizontalRef = apiRef.current.virtualScrollbarHorizontalRef;\n  const contentHeight = dimensions.contentSize.height;\n  const columnsTotalWidth = dimensions.columnsTotalWidth;\n  const hasColSpan = useGridSelector(apiRef, gridHasColSpanSelector);\n  const mainRefCallback = React.useCallback(node => {\n    mainRef.current = node;\n    if (!node) {\n      return undefined;\n    }\n    const initialRect = node.getBoundingClientRect();\n    let lastSize = {\n      width: initialRect.width,\n      height: initialRect.height\n    };\n    apiRef.current.publishEvent('resize', lastSize);\n    if (typeof ResizeObserver === 'undefined') {\n      return undefined;\n    }\n    const observer = new ResizeObserver(entries => {\n      const entry = entries[0];\n      if (!entry) {\n        return;\n      }\n      const newSize = {\n        width: entry.contentRect.width,\n        height: entry.contentRect.height\n      };\n      if (newSize.width === lastSize.width && newSize.height === lastSize.height) {\n        return;\n      }\n      apiRef.current.publishEvent('resize', newSize);\n      lastSize = newSize;\n    });\n    observer.observe(node);\n    if (reactMajor >= 19) {\n      return () => {\n        mainRef.current = null;\n        observer.disconnect();\n      };\n    }\n    return undefined;\n  }, [apiRef, mainRef]);\n\n  /*\n   * Scroll context logic\n   * ====================\n   * We only render the cells contained in the `renderContext`. However, when the user starts scrolling the grid\n   * in a direction, we want to render as many cells as possible in that direction, as to avoid presenting white\n   * areas if the user scrolls too fast/far and the viewport ends up in a region we haven't rendered yet. To render\n   * more cells, we store some offsets to add to the viewport in `scrollCache.buffer`. Those offsets make the render\n   * context wider in the direction the user is going, but also makes the buffer around the viewport `0` for the\n   * dimension (horizontal or vertical) in which the user is not scrolling. So if the normal viewport is 8 columns\n   * wide, with a 1 column buffer (10 columns total), then we want it to be exactly 8 columns wide during vertical\n   * scroll.\n   * However, we don't want the rows in the old context to re-render from e.g. 10 columns to 8 columns, because that's\n   * work that's not necessary. Thus we store the context at the start of the scroll in `frozenContext`, and the rows\n   * that are part of this old context will keep their same render context as to avoid re-rendering.\n   */\n  const scrollPosition = React.useRef(EMPTY_SCROLL_POSITION);\n  const previousContextScrollPosition = React.useRef(EMPTY_SCROLL_POSITION);\n  const previousRowContext = React.useRef(EMPTY_RENDER_CONTEXT);\n  const renderContext = useGridSelector(apiRef, gridRenderContextSelector);\n  const scrollTimeout = useTimeout();\n  const frozenContext = React.useRef(undefined);\n  const scrollCache = useLazyRef(() => createScrollCache(isRtl, rootProps.rowBufferPx, rootProps.columnBufferPx, dimensions.rowHeight * 15, MINIMUM_COLUMN_WIDTH * 6)).current;\n  const focusedCell = {\n    rowIndex: React.useMemo(() => cellFocus ? currentPage.rows.findIndex(row => row.id === cellFocus.id) : -1, [cellFocus, currentPage.rows]),\n    columnIndex: React.useMemo(() => cellFocus ? visibleColumns.findIndex(column => column.field === cellFocus.field) : -1, [cellFocus, visibleColumns])\n  };\n  const updateRenderContext = React.useCallback(nextRenderContext => {\n    if (areRenderContextsEqual(nextRenderContext, apiRef.current.state.virtualization.renderContext)) {\n      return;\n    }\n    const didRowsIntervalChange = nextRenderContext.firstRowIndex !== previousRowContext.current.firstRowIndex || nextRenderContext.lastRowIndex !== previousRowContext.current.lastRowIndex;\n    apiRef.current.setState(state => {\n      return _extends({}, state, {\n        virtualization: _extends({}, state.virtualization, {\n          renderContext: nextRenderContext\n        })\n      });\n    });\n\n    // The lazy-loading hook is listening to `renderedRowsIntervalChange`,\n    // but only does something if the dimensions are also available.\n    // So we wait until we have valid dimensions before publishing the first event.\n    if (dimensions.isReady && didRowsIntervalChange) {\n      previousRowContext.current = nextRenderContext;\n      apiRef.current.publishEvent('renderedRowsIntervalChange', nextRenderContext);\n    }\n    previousContextScrollPosition.current = scrollPosition.current;\n  }, [apiRef, dimensions.isReady]);\n  const triggerUpdateRenderContext = useEventCallback(() => {\n    const scroller = scrollerRef.current;\n    if (!scroller) {\n      return undefined;\n    }\n    const newScroll = {\n      top: scroller.scrollTop,\n      left: scroller.scrollLeft\n    };\n    const dx = newScroll.left - scrollPosition.current.left;\n    const dy = newScroll.top - scrollPosition.current.top;\n    const isScrolling = dx !== 0 || dy !== 0;\n    scrollPosition.current = newScroll;\n    const direction = isScrolling ? directionForDelta(dx, dy) : ScrollDirection.NONE;\n\n    // Since previous render, we have scrolled...\n    const rowScroll = Math.abs(scrollPosition.current.top - previousContextScrollPosition.current.top);\n    const columnScroll = Math.abs(scrollPosition.current.left - previousContextScrollPosition.current.left);\n\n    // PERF: use the computed minimum column width instead of a static one\n    const didCrossThreshold = rowScroll >= dimensions.rowHeight || columnScroll >= MINIMUM_COLUMN_WIDTH;\n    const didChangeDirection = scrollCache.direction !== direction;\n    const shouldUpdate = didCrossThreshold || didChangeDirection;\n    if (!shouldUpdate) {\n      return renderContext;\n    }\n\n    // Render a new context\n\n    if (didChangeDirection) {\n      switch (direction) {\n        case ScrollDirection.NONE:\n        case ScrollDirection.LEFT:\n        case ScrollDirection.RIGHT:\n          frozenContext.current = undefined;\n          break;\n        default:\n          frozenContext.current = renderContext;\n          break;\n      }\n    }\n    scrollCache.direction = direction;\n    scrollCache.buffer = bufferForDirection(isRtl, direction, rootProps.rowBufferPx, rootProps.columnBufferPx, dimensions.rowHeight * 15, MINIMUM_COLUMN_WIDTH * 6);\n    const inputs = inputsSelector(apiRef, rootProps, enabledForRows, enabledForColumns);\n    const nextRenderContext = computeRenderContext(inputs, scrollPosition.current, scrollCache);\n\n    // Prevents batching render context changes\n    ReactDOM.flushSync(() => {\n      updateRenderContext(nextRenderContext);\n    });\n    scrollTimeout.start(1000, triggerUpdateRenderContext);\n    return nextRenderContext;\n  });\n  const forceUpdateRenderContext = () => {\n    const inputs = inputsSelector(apiRef, rootProps, enabledForRows, enabledForColumns);\n    const nextRenderContext = computeRenderContext(inputs, scrollPosition.current, scrollCache);\n    // Reset the frozen context when the render context changes, see the illustration in https://github.com/mui/mui-x/pull/12353\n    frozenContext.current = undefined;\n    updateRenderContext(nextRenderContext);\n  };\n  const handleScroll = useEventCallback(event => {\n    const {\n      scrollTop,\n      scrollLeft\n    } = event.currentTarget;\n\n    // On iOS and macOS, negative offsets are possible when swiping past the start\n    if (scrollTop < 0) {\n      return;\n    }\n    if (!isRtl) {\n      if (scrollLeft < 0) {\n        return;\n      }\n    }\n    if (isRtl) {\n      if (scrollLeft > 0) {\n        return;\n      }\n    }\n    const nextRenderContext = triggerUpdateRenderContext();\n    apiRef.current.publishEvent('scrollPositionChange', {\n      top: scrollTop,\n      left: scrollLeft,\n      renderContext: nextRenderContext\n    });\n  });\n  const handleWheel = useEventCallback(event => {\n    apiRef.current.publishEvent('virtualScrollerWheel', {}, event);\n  });\n  const handleTouchMove = useEventCallback(event => {\n    apiRef.current.publishEvent('virtualScrollerTouchMove', {}, event);\n  });\n  const getRows = function () {\n    var _params$renderContext, _params$rows, _rootProps$slotProps;\n    let params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    if (!params.rows && !currentPage.range) {\n      return [];\n    }\n    const baseRenderContext = (_params$renderContext = params.renderContext) !== null && _params$renderContext !== void 0 ? _params$renderContext : renderContext;\n    const isLastSection = !hasBottomPinnedRows && params.position === undefined || hasBottomPinnedRows && params.position === 'bottom';\n    const isPinnedSection = params.position !== undefined;\n    let rowIndexOffset;\n    // FIXME: Why is the switch check exhaustiveness not validated with typescript-eslint?\n    // eslint-disable-next-line default-case\n    switch (params.position) {\n      case 'top':\n        rowIndexOffset = 0;\n        break;\n      case 'bottom':\n        rowIndexOffset = pinnedRows.top.length + currentPage.rows.length;\n        break;\n      case undefined:\n        rowIndexOffset = pinnedRows.top.length;\n        break;\n    }\n    const rowModels = (_params$rows = params.rows) !== null && _params$rows !== void 0 ? _params$rows : currentPage.rows;\n    const firstRowToRender = baseRenderContext.firstRowIndex;\n    const lastRowToRender = Math.min(baseRenderContext.lastRowIndex, rowModels.length);\n    const rowIndexes = params.rows ? range(0, params.rows.length) : range(firstRowToRender, lastRowToRender);\n    let virtualRowIndex = -1;\n    if (!isPinnedSection && focusedCell.rowIndex !== -1) {\n      if (focusedCell.rowIndex < firstRowToRender) {\n        virtualRowIndex = focusedCell.rowIndex;\n        rowIndexes.unshift(virtualRowIndex);\n      }\n      if (focusedCell.rowIndex >= lastRowToRender) {\n        virtualRowIndex = focusedCell.rowIndex;\n        rowIndexes.push(virtualRowIndex);\n      }\n    }\n    const rows = [];\n    const rowProps = (_rootProps$slotProps = rootProps.slotProps) === null || _rootProps$slotProps === void 0 ? void 0 : _rootProps$slotProps.row;\n    const columnPositions = gridColumnPositionsSelector(apiRef);\n    rowIndexes.forEach(rowIndexInPage => {\n      var _currentPage$range;\n      const {\n        id,\n        model\n      } = rowModels[rowIndexInPage];\n      const rowIndex = ((currentPage === null || currentPage === void 0 || (_currentPage$range = currentPage.range) === null || _currentPage$range === void 0 ? void 0 : _currentPage$range.firstRowIndex) || 0) + rowIndexOffset + rowIndexInPage;\n\n      // NOTE: This is an expensive feature, the colSpan code could be optimized.\n      if (hasColSpan) {\n        const minFirstColumn = pinnedColumns.left.length;\n        const maxLastColumn = visibleColumns.length - pinnedColumns.right.length;\n        apiRef.current.calculateColSpan({\n          rowId: id,\n          minFirstColumn,\n          maxLastColumn,\n          columns: visibleColumns\n        });\n        if (pinnedColumns.left.length > 0) {\n          apiRef.current.calculateColSpan({\n            rowId: id,\n            minFirstColumn: 0,\n            maxLastColumn: pinnedColumns.left.length,\n            columns: visibleColumns\n          });\n        }\n        if (pinnedColumns.right.length > 0) {\n          apiRef.current.calculateColSpan({\n            rowId: id,\n            minFirstColumn: visibleColumns.length - pinnedColumns.right.length,\n            maxLastColumn: visibleColumns.length,\n            columns: visibleColumns\n          });\n        }\n      }\n      const hasFocus = (cellFocus === null || cellFocus === void 0 ? void 0 : cellFocus.id) === id;\n      const baseRowHeight = !apiRef.current.rowHasAutoHeight(id) ? apiRef.current.unstable_getRowHeight(id) : 'auto';\n      let isSelected;\n      if (selectedRowsLookup[id] == null) {\n        isSelected = false;\n      } else {\n        isSelected = apiRef.current.isRowSelectable(id);\n      }\n      let isFirstVisible = false;\n      if (params.position === undefined) {\n        isFirstVisible = rowIndexInPage === 0;\n      }\n      let isLastVisible = false;\n      const isLastVisibleInSection = rowIndexInPage === rowModels.length - 1;\n      if (isLastSection) {\n        if (!isPinnedSection) {\n          const lastIndex = currentPage.rows.length - 1;\n          const isLastVisibleRowIndex = rowIndexInPage === lastIndex;\n          if (isLastVisibleRowIndex) {\n            isLastVisible = true;\n          }\n        } else {\n          isLastVisible = isLastVisibleInSection;\n        }\n      }\n      const isVirtualRow = rowIndexInPage === virtualRowIndex;\n      const isNotVisible = isVirtualRow;\n      let tabbableCell = null;\n      if (cellTabIndex !== null && cellTabIndex.id === id) {\n        const cellParams = apiRef.current.getCellParams(id, cellTabIndex.field);\n        tabbableCell = cellParams.cellMode === 'view' ? cellTabIndex.field : null;\n      }\n      let currentRenderContext = baseRenderContext;\n      if (!isPinnedSection && frozenContext.current && rowIndexInPage >= frozenContext.current.firstRowIndex && rowIndexInPage < frozenContext.current.lastRowIndex) {\n        currentRenderContext = frozenContext.current;\n      }\n      const offsetLeft = computeOffsetLeft(columnPositions, currentRenderContext, pinnedColumns.left.length);\n      const showBottomBorder = isLastVisibleInSection && params.position === 'top';\n      rows.push(/*#__PURE__*/_jsx(rootProps.slots.row, _extends({\n        row: model,\n        rowId: id,\n        index: rowIndex,\n        selected: isSelected,\n        offsetTop: params.rows ? undefined : rowsMeta.positions[rowIndexInPage],\n        offsetLeft: offsetLeft,\n        dimensions: dimensions,\n        rowHeight: baseRowHeight,\n        tabbableCell: tabbableCell,\n        pinnedColumns: pinnedColumns,\n        visibleColumns: visibleColumns,\n        renderContext: currentRenderContext,\n        focusedColumnIndex: hasFocus ? focusedCell.columnIndex : undefined,\n        isFirstVisible: isFirstVisible,\n        isLastVisible: isLastVisible,\n        isNotVisible: isNotVisible,\n        showBottomBorder: showBottomBorder\n      }, rowProps), id));\n      if (isNotVisible) {\n        return;\n      }\n      const panel = panels.get(id);\n      if (panel) {\n        rows.push(panel);\n      }\n      if (params.position === undefined && isLastVisibleInSection) {\n        var _apiRef$current$getIn, _apiRef$current;\n        rows.push((_apiRef$current$getIn = (_apiRef$current = apiRef.current).getInfiniteLoadingTriggerElement) === null || _apiRef$current$getIn === void 0 ? void 0 : _apiRef$current$getIn.call(_apiRef$current, {\n          lastRowId: id\n        }));\n      }\n    });\n    return rows;\n  };\n  const needsHorizontalScrollbar = outerSize.width && columnsTotalWidth > outerSize.width;\n  const scrollerStyle = React.useMemo(() => ({\n    overflowX: !needsHorizontalScrollbar || listView ? 'hidden' : undefined,\n    overflowY: rootProps.autoHeight ? 'hidden' : undefined\n  }), [needsHorizontalScrollbar, rootProps.autoHeight, listView]);\n  const contentSize = React.useMemo(() => {\n    const size = {\n      width: needsHorizontalScrollbar ? columnsTotalWidth : 'auto',\n      flexBasis: contentHeight,\n      flexShrink: 0\n    };\n    if (size.flexBasis === 0) {\n      size.flexBasis = minimalContentHeight; // Give room to show the overlay when there no rows.\n    }\n    return size;\n  }, [columnsTotalWidth, contentHeight, needsHorizontalScrollbar]);\n  React.useEffect(() => {\n    apiRef.current.publishEvent('virtualScrollerContentSizeChange');\n  }, [apiRef, contentSize]);\n  useEnhancedEffect(() => {\n    // TODO a scroll reset should not be necessary\n    if (enabledForColumns) {\n      scrollerRef.current.scrollLeft = 0;\n    }\n    if (enabledForRows) {\n      scrollerRef.current.scrollTop = 0;\n    }\n  }, [enabledForColumns, enabledForRows, gridRootRef, scrollerRef]);\n  useEnhancedEffect(() => {\n    if (listView) {\n      scrollerRef.current.scrollLeft = 0;\n    }\n  }, [listView, scrollerRef]);\n  useRunOnce(outerSize.width !== 0, () => {\n    const inputs = inputsSelector(apiRef, rootProps, enabledForRows, enabledForColumns);\n    const initialRenderContext = computeRenderContext(inputs, scrollPosition.current, scrollCache);\n    updateRenderContext(initialRenderContext);\n    apiRef.current.publishEvent('scrollPositionChange', {\n      top: scrollPosition.current.top,\n      left: scrollPosition.current.left,\n      renderContext: initialRenderContext\n    });\n  });\n  apiRef.current.register('private', {\n    updateRenderContext: forceUpdateRenderContext\n  });\n  useGridApiEventHandler(apiRef, 'columnsChange', forceUpdateRenderContext);\n  useGridApiEventHandler(apiRef, 'filteredRowsSet', forceUpdateRenderContext);\n  useGridApiEventHandler(apiRef, 'rowExpansionChange', forceUpdateRenderContext);\n  return {\n    renderContext,\n    setPanels,\n    getRows,\n    getContainerProps: () => ({\n      ref: mainRefCallback\n    }),\n    getScrollerProps: () => ({\n      ref: scrollerRef,\n      onScroll: handleScroll,\n      onWheel: handleWheel,\n      onTouchMove: handleTouchMove,\n      style: scrollerStyle,\n      role: 'presentation',\n      // `tabIndex` shouldn't be used along role=presentation, but it fixes a Firefox bug\n      // https://github.com/mui/mui-x/pull/13891#discussion_r1683416024\n      tabIndex: platform.isFirefox ? -1 : undefined\n    }),\n    getContentProps: () => ({\n      style: contentSize,\n      role: 'presentation'\n    }),\n    getRenderZoneProps: () => ({\n      role: 'rowgroup'\n    }),\n    getScrollbarVerticalProps: () => ({\n      ref: scrollbarVerticalRef,\n      role: 'presentation'\n    }),\n    getScrollbarHorizontalProps: () => ({\n      ref: scrollbarHorizontalRef,\n      role: 'presentation'\n    })\n  };\n};\nfunction inputsSelector(apiRef, rootProps, enabledForRows, enabledForColumns) {\n  var _lastColumn$computedW, _rootProps$unstable_l;\n  const dimensions = gridDimensionsSelector(apiRef.current.state);\n  const currentPage = getVisibleRows(apiRef, rootProps);\n  const visibleColumns = rootProps.unstable_listView ? [gridListColumnSelector(apiRef.current.state)] : gridVisibleColumnDefinitionsSelector(apiRef);\n  const hiddenCellsOriginMap = gridRowSpanningHiddenCellsOriginMapSelector(apiRef);\n  const lastRowId = apiRef.current.state.rows.dataRowIds.at(-1);\n  const lastColumn = visibleColumns.at(-1);\n  return {\n    enabledForRows,\n    enabledForColumns,\n    apiRef,\n    autoHeight: rootProps.autoHeight,\n    rowBufferPx: rootProps.rowBufferPx,\n    columnBufferPx: rootProps.columnBufferPx,\n    leftPinnedWidth: dimensions.leftPinnedWidth,\n    columnsTotalWidth: dimensions.columnsTotalWidth,\n    viewportInnerWidth: dimensions.viewportInnerSize.width,\n    viewportInnerHeight: dimensions.viewportInnerSize.height,\n    lastRowHeight: lastRowId !== undefined ? apiRef.current.unstable_getRowHeight(lastRowId) : 0,\n    lastColumnWidth: (_lastColumn$computedW = lastColumn === null || lastColumn === void 0 ? void 0 : lastColumn.computedWidth) !== null && _lastColumn$computedW !== void 0 ? _lastColumn$computedW : 0,\n    rowsMeta: gridRowsMetaSelector(apiRef.current.state),\n    columnPositions: gridColumnPositionsSelector(apiRef),\n    rows: currentPage.rows,\n    range: currentPage.range,\n    pinnedColumns: gridVisiblePinnedColumnDefinitionsSelector(apiRef),\n    visibleColumns,\n    hiddenCellsOriginMap,\n    listView: (_rootProps$unstable_l = rootProps.unstable_listView) !== null && _rootProps$unstable_l !== void 0 ? _rootProps$unstable_l : false,\n    virtualizeColumnsWithAutoRowHeight: rootProps.virtualizeColumnsWithAutoRowHeight\n  };\n}\nfunction computeRenderContext(inputs, scrollPosition, scrollCache) {\n  const renderContext = {\n    firstRowIndex: 0,\n    lastRowIndex: inputs.rows.length,\n    firstColumnIndex: 0,\n    lastColumnIndex: inputs.visibleColumns.length\n  };\n  const {\n    top,\n    left\n  } = scrollPosition;\n  const realLeft = Math.abs(left) + inputs.leftPinnedWidth;\n  if (inputs.enabledForRows) {\n    // Clamp the value because the search may return an index out of bounds.\n    // In the last index, this is not needed because Array.slice doesn't include it.\n    let firstRowIndex = Math.min(getNearestIndexToRender(inputs, top, {\n      atStart: true,\n      lastPosition: inputs.rowsMeta.positions[inputs.rowsMeta.positions.length - 1] + inputs.lastRowHeight\n    }), inputs.rowsMeta.positions.length - 1);\n\n    // If any of the cells in the `firstRowIndex` is hidden due to an extended row span,\n    // Make sure the row from where the rowSpan is originated is visible.\n    const rowSpanHiddenCellOrigin = inputs.hiddenCellsOriginMap[firstRowIndex];\n    if (rowSpanHiddenCellOrigin) {\n      const minSpannedRowIndex = Math.min(...Object.values(rowSpanHiddenCellOrigin));\n      firstRowIndex = Math.min(firstRowIndex, minSpannedRowIndex);\n    }\n    const lastRowIndex = inputs.autoHeight ? firstRowIndex + inputs.rows.length : getNearestIndexToRender(inputs, top + inputs.viewportInnerHeight);\n    renderContext.firstRowIndex = firstRowIndex;\n    renderContext.lastRowIndex = lastRowIndex;\n  }\n  if (inputs.enabledForColumns) {\n    let firstColumnIndex = 0;\n    let lastColumnIndex = inputs.columnPositions.length;\n    let hasRowWithAutoHeight = false;\n    const [firstRowToRender, lastRowToRender] = getIndexesToRender({\n      firstIndex: renderContext.firstRowIndex,\n      lastIndex: renderContext.lastRowIndex,\n      minFirstIndex: 0,\n      maxLastIndex: inputs.rows.length,\n      bufferBefore: scrollCache.buffer.rowBefore,\n      bufferAfter: scrollCache.buffer.rowAfter,\n      positions: inputs.rowsMeta.positions,\n      lastSize: inputs.lastRowHeight\n    });\n    if (!inputs.virtualizeColumnsWithAutoRowHeight) {\n      for (let i = firstRowToRender; i < lastRowToRender && !hasRowWithAutoHeight; i += 1) {\n        const row = inputs.rows[i];\n        hasRowWithAutoHeight = inputs.apiRef.current.rowHasAutoHeight(row.id);\n      }\n    }\n    if (!hasRowWithAutoHeight || inputs.virtualizeColumnsWithAutoRowHeight) {\n      firstColumnIndex = binarySearch(realLeft, inputs.columnPositions, {\n        atStart: true,\n        lastPosition: inputs.columnsTotalWidth\n      });\n      lastColumnIndex = binarySearch(realLeft + inputs.viewportInnerWidth, inputs.columnPositions);\n    }\n    renderContext.firstColumnIndex = firstColumnIndex;\n    renderContext.lastColumnIndex = lastColumnIndex;\n  }\n  const actualRenderContext = deriveRenderContext(inputs, renderContext, scrollCache);\n  return actualRenderContext;\n}\nfunction getNearestIndexToRender(inputs, offset, options) {\n  var _inputs$range, _inputs$range2;\n  const lastMeasuredIndexRelativeToAllRows = inputs.apiRef.current.getLastMeasuredRowIndex();\n  let allRowsMeasured = lastMeasuredIndexRelativeToAllRows === Infinity;\n  if ((_inputs$range = inputs.range) !== null && _inputs$range !== void 0 && _inputs$range.lastRowIndex && !allRowsMeasured) {\n    // Check if all rows in this page are already measured\n    allRowsMeasured = lastMeasuredIndexRelativeToAllRows >= inputs.range.lastRowIndex;\n  }\n  const lastMeasuredIndexRelativeToCurrentPage = clamp(lastMeasuredIndexRelativeToAllRows - (((_inputs$range2 = inputs.range) === null || _inputs$range2 === void 0 ? void 0 : _inputs$range2.firstRowIndex) || 0), 0, inputs.rowsMeta.positions.length);\n  if (allRowsMeasured || inputs.rowsMeta.positions[lastMeasuredIndexRelativeToCurrentPage] >= offset) {\n    // If all rows were measured (when no row has \"auto\" as height) or all rows before the offset\n    // were measured, then use a binary search because it's faster.\n    return binarySearch(offset, inputs.rowsMeta.positions, options);\n  }\n\n  // Otherwise, use an exponential search.\n  // If rows have \"auto\" as height, their positions will be based on estimated heights.\n  // In this case, we can skip several steps until we find a position higher than the offset.\n  // Inspired by https://github.com/bvaughn/react-virtualized/blob/master/source/Grid/utils/CellSizeAndPositionManager.js\n  return exponentialSearch(offset, inputs.rowsMeta.positions, lastMeasuredIndexRelativeToCurrentPage, options);\n}\n\n/**\n * Accepts as input a raw render context (the area visible in the viewport) and adds\n * computes the actual render context based on pinned elements, buffer dimensions and\n * spanning.\n */\nfunction deriveRenderContext(inputs, nextRenderContext, scrollCache) {\n  const [firstRowToRender, lastRowToRender] = getIndexesToRender({\n    firstIndex: nextRenderContext.firstRowIndex,\n    lastIndex: nextRenderContext.lastRowIndex,\n    minFirstIndex: 0,\n    maxLastIndex: inputs.rows.length,\n    bufferBefore: scrollCache.buffer.rowBefore,\n    bufferAfter: scrollCache.buffer.rowAfter,\n    positions: inputs.rowsMeta.positions,\n    lastSize: inputs.lastRowHeight\n  });\n  const [initialFirstColumnToRender, lastColumnToRender] = getIndexesToRender({\n    firstIndex: nextRenderContext.firstColumnIndex,\n    lastIndex: nextRenderContext.lastColumnIndex,\n    minFirstIndex: inputs.pinnedColumns.left.length,\n    maxLastIndex: inputs.visibleColumns.length - inputs.pinnedColumns.right.length,\n    bufferBefore: scrollCache.buffer.columnBefore,\n    bufferAfter: scrollCache.buffer.columnAfter,\n    positions: inputs.columnPositions,\n    lastSize: inputs.lastColumnWidth\n  });\n  const firstColumnToRender = getFirstNonSpannedColumnToRender({\n    firstColumnToRender: initialFirstColumnToRender,\n    apiRef: inputs.apiRef,\n    firstRowToRender,\n    lastRowToRender,\n    visibleRows: inputs.rows\n  });\n  return {\n    firstRowIndex: firstRowToRender,\n    lastRowIndex: lastRowToRender,\n    firstColumnIndex: firstColumnToRender,\n    lastColumnIndex: lastColumnToRender\n  };\n}\n/**\n * Use binary search to avoid looping through all possible positions.\n * The `options.atStart` provides the possibility to match for the first element that\n * intersects the screen, even if said element's start position is before `offset`. In\n * other words, we search for `offset + width`.\n */\nfunction binarySearch(offset, positions) {\n  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;\n  let sliceStart = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n  let sliceEnd = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : positions.length;\n  if (positions.length <= 0) {\n    return -1;\n  }\n  if (sliceStart >= sliceEnd) {\n    return sliceStart;\n  }\n  const pivot = sliceStart + Math.floor((sliceEnd - sliceStart) / 2);\n  const position = positions[pivot];\n  let isBefore;\n  if (options !== null && options !== void 0 && options.atStart) {\n    const width = (pivot === positions.length - 1 ? options.lastPosition : positions[pivot + 1]) - position;\n    isBefore = offset - width < position;\n  } else {\n    isBefore = offset <= position;\n  }\n  return isBefore ? binarySearch(offset, positions, options, sliceStart, pivot) : binarySearch(offset, positions, options, pivot + 1, sliceEnd);\n}\nfunction exponentialSearch(offset, positions, index) {\n  let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : undefined;\n  let interval = 1;\n  while (index < positions.length && Math.abs(positions[index]) < offset) {\n    index += interval;\n    interval *= 2;\n  }\n  return binarySearch(offset, positions, options, Math.floor(index / 2), Math.min(index, positions.length));\n}\nfunction getIndexesToRender(_ref) {\n  let {\n    firstIndex,\n    lastIndex,\n    bufferBefore,\n    bufferAfter,\n    minFirstIndex,\n    maxLastIndex,\n    positions,\n    lastSize\n  } = _ref;\n  const firstPosition = positions[firstIndex] - bufferBefore;\n  const lastPosition = positions[lastIndex] + bufferAfter;\n  const firstIndexPadded = binarySearch(firstPosition, positions, {\n    atStart: true,\n    lastPosition: positions[positions.length - 1] + lastSize\n  });\n  const lastIndexPadded = binarySearch(lastPosition, positions);\n  return [clamp(firstIndexPadded, minFirstIndex, maxLastIndex), clamp(lastIndexPadded, minFirstIndex, maxLastIndex)];\n}\nexport function areRenderContextsEqual(context1, context2) {\n  if (context1 === context2) {\n    return true;\n  }\n  return context1.firstRowIndex === context2.firstRowIndex && context1.lastRowIndex === context2.lastRowIndex && context1.firstColumnIndex === context2.firstColumnIndex && context1.lastColumnIndex === context2.lastColumnIndex;\n}\nexport function computeOffsetLeft(columnPositions, renderContext, pinnedLeftLength) {\n  var _columnPositions$rend, _columnPositions$pinn;\n  const left = ((_columnPositions$rend = columnPositions[renderContext.firstColumnIndex]) !== null && _columnPositions$rend !== void 0 ? _columnPositions$rend : 0) - ((_columnPositions$pinn = columnPositions[pinnedLeftLength]) !== null && _columnPositions$pinn !== void 0 ? _columnPositions$pinn : 0);\n  return Math.abs(left);\n}\nfunction directionForDelta(dx, dy) {\n  if (dx === 0 && dy === 0) {\n    return ScrollDirection.NONE;\n  }\n  /* eslint-disable */\n  if (Math.abs(dy) >= Math.abs(dx)) {\n    if (dy > 0) {\n      return ScrollDirection.DOWN;\n    } else {\n      return ScrollDirection.UP;\n    }\n  } else {\n    if (dx > 0) {\n      return ScrollDirection.RIGHT;\n    } else {\n      return ScrollDirection.LEFT;\n    }\n  }\n  /* eslint-enable */\n}\nfunction bufferForDirection(isRtl, direction, rowBufferPx, columnBufferPx, verticalBuffer, horizontalBuffer) {\n  if (isRtl) {\n    switch (direction) {\n      case ScrollDirection.LEFT:\n        direction = ScrollDirection.RIGHT;\n        break;\n      case ScrollDirection.RIGHT:\n        direction = ScrollDirection.LEFT;\n        break;\n      default:\n    }\n  }\n  switch (direction) {\n    case ScrollDirection.NONE:\n      return {\n        rowAfter: rowBufferPx,\n        rowBefore: rowBufferPx,\n        columnAfter: columnBufferPx,\n        columnBefore: columnBufferPx\n      };\n    case ScrollDirection.LEFT:\n      return {\n        rowAfter: 0,\n        rowBefore: 0,\n        columnAfter: 0,\n        columnBefore: horizontalBuffer\n      };\n    case ScrollDirection.RIGHT:\n      return {\n        rowAfter: 0,\n        rowBefore: 0,\n        columnAfter: horizontalBuffer,\n        columnBefore: 0\n      };\n    case ScrollDirection.UP:\n      return {\n        rowAfter: 0,\n        rowBefore: verticalBuffer,\n        columnAfter: 0,\n        columnBefore: 0\n      };\n    case ScrollDirection.DOWN:\n      return {\n        rowAfter: verticalBuffer,\n        rowBefore: 0,\n        columnAfter: 0,\n        columnBefore: 0\n      };\n    default:\n      // eslint unable to figure out enum exhaustiveness\n      throw new Error('unreachable');\n  }\n}","map":{"version":3,"names":["_extends","React","ReactDOM","unstable_useEnhancedEffect","useEnhancedEffect","unstable_useEventCallback","useEventCallback","useLazyRef","useTimeout","useRtl","reactMajor","useGridPrivateApiContext","useGridRootProps","useGridSelector","useRunOnce","gridVisibleColumnDefinitionsSelector","gridVisiblePinnedColumnDefinitionsSelector","gridColumnPositionsSelector","gridHasColSpanSelector","gridDimensionsSelector","gridPinnedRowsSelector","gridFocusCellSelector","gridTabIndexCellSelector","useGridVisibleRows","getVisibleRows","useGridApiEventHandler","platform","clamp","range","selectedIdsLookupSelector","gridRowsMetaSelector","getFirstNonSpannedColumnToRender","gridRenderContextSelector","gridVirtualizationRowEnabledSelector","gridVirtualizationColumnEnabledSelector","EMPTY_RENDER_CONTEXT","gridRowSpanningHiddenCellsOriginMapSelector","gridListColumnSelector","minimalContentHeight","jsx","_jsx","MINIMUM_COLUMN_WIDTH","ScrollDirection","EMPTY_SCROLL_POSITION","top","left","EMPTY_DETAIL_PANELS","Object","freeze","Map","createScrollCache","isRtl","rowBufferPx","columnBufferPx","verticalBuffer","horizontalBuffer","direction","NONE","buffer","bufferForDirection","isJSDOM","window","test","navigator","userAgent","_","useGridVirtualScroller","apiRef","rootProps","unstable_listView","listView","visibleColumns","current","state","enabledForRows","enabledForColumns","dimensions","outerSize","viewportOuterSize","pinnedRows","pinnedColumnDefinitions","pinnedColumns","right","hasBottomPinnedRows","bottom","length","panels","setPanels","useState","cellFocus","cellTabIndex","rowsMeta","selectedRowsLookup","currentPage","gridRootRef","rootElementRef","mainRef","mainElementRef","scrollerRef","virtualScrollerRef","scrollbarVerticalRef","virtualScrollbarVerticalRef","scrollbarHorizontalRef","virtualScrollbarHorizontalRef","contentHeight","contentSize","height","columnsTotalWidth","hasColSpan","mainRefCallback","useCallback","node","undefined","initialRect","getBoundingClientRect","lastSize","width","publishEvent","ResizeObserver","observer","entries","entry","newSize","contentRect","observe","disconnect","scrollPosition","useRef","previousContextScrollPosition","previousRowContext","renderContext","scrollTimeout","frozenContext","scrollCache","rowHeight","focusedCell","rowIndex","useMemo","rows","findIndex","row","id","columnIndex","column","field","updateRenderContext","nextRenderContext","areRenderContextsEqual","virtualization","didRowsIntervalChange","firstRowIndex","lastRowIndex","setState","isReady","triggerUpdateRenderContext","scroller","newScroll","scrollTop","scrollLeft","dx","dy","isScrolling","directionForDelta","rowScroll","Math","abs","columnScroll","didCrossThreshold","didChangeDirection","shouldUpdate","LEFT","RIGHT","inputs","inputsSelector","computeRenderContext","flushSync","start","forceUpdateRenderContext","handleScroll","event","currentTarget","handleWheel","handleTouchMove","getRows","_params$renderContext","_params$rows","_rootProps$slotProps","params","arguments","baseRenderContext","isLastSection","position","isPinnedSection","rowIndexOffset","rowModels","firstRowToRender","lastRowToRender","min","rowIndexes","virtualRowIndex","unshift","push","rowProps","slotProps","columnPositions","forEach","rowIndexInPage","_currentPage$range","model","minFirstColumn","maxLastColumn","calculateColSpan","rowId","columns","hasFocus","baseRowHeight","rowHasAutoHeight","unstable_getRowHeight","isSelected","isRowSelectable","isFirstVisible","isLastVisible","isLastVisibleInSection","lastIndex","isLastVisibleRowIndex","isVirtualRow","isNotVisible","tabbableCell","cellParams","getCellParams","cellMode","currentRenderContext","offsetLeft","computeOffsetLeft","showBottomBorder","slots","index","selected","offsetTop","positions","focusedColumnIndex","panel","get","_apiRef$current$getIn","_apiRef$current","getInfiniteLoadingTriggerElement","call","lastRowId","needsHorizontalScrollbar","scrollerStyle","overflowX","overflowY","autoHeight","size","flexBasis","flexShrink","useEffect","initialRenderContext","register","getContainerProps","ref","getScrollerProps","onScroll","onWheel","onTouchMove","style","role","tabIndex","isFirefox","getContentProps","getRenderZoneProps","getScrollbarVerticalProps","getScrollbarHorizontalProps","_lastColumn$computedW","_rootProps$unstable_l","hiddenCellsOriginMap","dataRowIds","at","lastColumn","leftPinnedWidth","viewportInnerWidth","viewportInnerSize","viewportInnerHeight","lastRowHeight","lastColumnWidth","computedWidth","virtualizeColumnsWithAutoRowHeight","firstColumnIndex","lastColumnIndex","realLeft","getNearestIndexToRender","atStart","lastPosition","rowSpanHiddenCellOrigin","minSpannedRowIndex","values","hasRowWithAutoHeight","getIndexesToRender","firstIndex","minFirstIndex","maxLastIndex","bufferBefore","rowBefore","bufferAfter","rowAfter","i","binarySearch","actualRenderContext","deriveRenderContext","offset","options","_inputs$range","_inputs$range2","lastMeasuredIndexRelativeToAllRows","getLastMeasuredRowIndex","allRowsMeasured","Infinity","lastMeasuredIndexRelativeToCurrentPage","exponentialSearch","initialFirstColumnToRender","lastColumnToRender","columnBefore","columnAfter","firstColumnToRender","visibleRows","sliceStart","sliceEnd","pivot","floor","isBefore","interval","_ref","firstPosition","firstIndexPadded","lastIndexPadded","context1","context2","pinnedLeftLength","_columnPositions$rend","_columnPositions$pinn","DOWN","UP","Error"],"sources":["/home/ubuntu/YARSI-Connect-Alumni-main/YARSI-Connect-Alumni-main/YARSI-Connect Alumni/front-end/node_modules/@mui/x-data-grid/hooks/features/virtualization/useGridVirtualScroller.js"],"sourcesContent":["import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport * as React from 'react';\nimport * as ReactDOM from 'react-dom';\nimport { unstable_useEnhancedEffect as useEnhancedEffect, unstable_useEventCallback as useEventCallback } from '@mui/utils';\nimport useLazyRef from '@mui/utils/useLazyRef';\nimport useTimeout from '@mui/utils/useTimeout';\nimport { useRtl } from '@mui/system/RtlProvider';\nimport reactMajor from '@mui/x-internals/reactMajor';\nimport { useGridPrivateApiContext } from \"../../utils/useGridPrivateApiContext.js\";\nimport { useGridRootProps } from \"../../utils/useGridRootProps.js\";\nimport { useGridSelector } from \"../../utils/useGridSelector.js\";\nimport { useRunOnce } from \"../../utils/useRunOnce.js\";\nimport { gridVisibleColumnDefinitionsSelector, gridVisiblePinnedColumnDefinitionsSelector, gridColumnPositionsSelector, gridHasColSpanSelector } from \"../columns/gridColumnsSelector.js\";\nimport { gridDimensionsSelector } from \"../dimensions/gridDimensionsSelectors.js\";\nimport { gridPinnedRowsSelector } from \"../rows/gridRowsSelector.js\";\nimport { gridFocusCellSelector, gridTabIndexCellSelector } from \"../focus/gridFocusStateSelector.js\";\nimport { useGridVisibleRows, getVisibleRows } from \"../../utils/useGridVisibleRows.js\";\nimport { useGridApiEventHandler } from \"../../utils/index.js\";\nimport * as platform from \"../../../utils/platform.js\";\nimport { clamp, range } from \"../../../utils/utils.js\";\nimport { selectedIdsLookupSelector } from \"../rowSelection/gridRowSelectionSelector.js\";\nimport { gridRowsMetaSelector } from \"../rows/gridRowsMetaSelector.js\";\nimport { getFirstNonSpannedColumnToRender } from \"../columns/gridColumnsUtils.js\";\nimport { gridRenderContextSelector, gridVirtualizationRowEnabledSelector, gridVirtualizationColumnEnabledSelector } from \"./gridVirtualizationSelectors.js\";\nimport { EMPTY_RENDER_CONTEXT } from \"./useGridVirtualization.js\";\nimport { gridRowSpanningHiddenCellsOriginMapSelector } from \"../rows/gridRowSpanningSelectors.js\";\nimport { gridListColumnSelector } from \"../listView/gridListViewSelectors.js\";\nimport { minimalContentHeight } from \"../rows/gridRowsUtils.js\";\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nconst MINIMUM_COLUMN_WIDTH = 50;\nvar ScrollDirection = /*#__PURE__*/function (ScrollDirection) {\n  ScrollDirection[ScrollDirection[\"NONE\"] = 0] = \"NONE\";\n  ScrollDirection[ScrollDirection[\"UP\"] = 1] = \"UP\";\n  ScrollDirection[ScrollDirection[\"DOWN\"] = 2] = \"DOWN\";\n  ScrollDirection[ScrollDirection[\"LEFT\"] = 3] = \"LEFT\";\n  ScrollDirection[ScrollDirection[\"RIGHT\"] = 4] = \"RIGHT\";\n  return ScrollDirection;\n}(ScrollDirection || {});\nconst EMPTY_SCROLL_POSITION = {\n  top: 0,\n  left: 0\n};\nexport const EMPTY_DETAIL_PANELS = Object.freeze(new Map());\nconst createScrollCache = (isRtl, rowBufferPx, columnBufferPx, verticalBuffer, horizontalBuffer) => ({\n  direction: ScrollDirection.NONE,\n  buffer: bufferForDirection(isRtl, ScrollDirection.NONE, rowBufferPx, columnBufferPx, verticalBuffer, horizontalBuffer)\n});\nlet isJSDOM = false;\ntry {\n  if (typeof window !== 'undefined') {\n    isJSDOM = /jsdom|HappyDOM/.test(window.navigator.userAgent);\n  }\n} catch (_) {\n  /* ignore */\n}\nexport const useGridVirtualScroller = () => {\n  const apiRef = useGridPrivateApiContext();\n  const rootProps = useGridRootProps();\n  const {\n    unstable_listView: listView\n  } = rootProps;\n  const visibleColumns = useGridSelector(apiRef, () => listView ? [gridListColumnSelector(apiRef.current.state)] : gridVisibleColumnDefinitionsSelector(apiRef));\n  const enabledForRows = useGridSelector(apiRef, gridVirtualizationRowEnabledSelector) && !isJSDOM;\n  const enabledForColumns = useGridSelector(apiRef, gridVirtualizationColumnEnabledSelector) && !isJSDOM;\n  const dimensions = useGridSelector(apiRef, gridDimensionsSelector);\n  const outerSize = dimensions.viewportOuterSize;\n  const pinnedRows = useGridSelector(apiRef, gridPinnedRowsSelector);\n  const pinnedColumnDefinitions = useGridSelector(apiRef, gridVisiblePinnedColumnDefinitionsSelector);\n  const pinnedColumns = listView ? {\n    left: [],\n    right: []\n  } : pinnedColumnDefinitions;\n  const hasBottomPinnedRows = pinnedRows.bottom.length > 0;\n  const [panels, setPanels] = React.useState(EMPTY_DETAIL_PANELS);\n  const isRtl = useRtl();\n  const cellFocus = useGridSelector(apiRef, gridFocusCellSelector);\n  const cellTabIndex = useGridSelector(apiRef, gridTabIndexCellSelector);\n  const rowsMeta = useGridSelector(apiRef, gridRowsMetaSelector);\n  const selectedRowsLookup = useGridSelector(apiRef, selectedIdsLookupSelector);\n  const currentPage = useGridVisibleRows(apiRef, rootProps);\n  const gridRootRef = apiRef.current.rootElementRef;\n  const mainRef = apiRef.current.mainElementRef;\n  const scrollerRef = apiRef.current.virtualScrollerRef;\n  const scrollbarVerticalRef = apiRef.current.virtualScrollbarVerticalRef;\n  const scrollbarHorizontalRef = apiRef.current.virtualScrollbarHorizontalRef;\n  const contentHeight = dimensions.contentSize.height;\n  const columnsTotalWidth = dimensions.columnsTotalWidth;\n  const hasColSpan = useGridSelector(apiRef, gridHasColSpanSelector);\n  const mainRefCallback = React.useCallback(node => {\n    mainRef.current = node;\n    if (!node) {\n      return undefined;\n    }\n    const initialRect = node.getBoundingClientRect();\n    let lastSize = {\n      width: initialRect.width,\n      height: initialRect.height\n    };\n    apiRef.current.publishEvent('resize', lastSize);\n    if (typeof ResizeObserver === 'undefined') {\n      return undefined;\n    }\n    const observer = new ResizeObserver(entries => {\n      const entry = entries[0];\n      if (!entry) {\n        return;\n      }\n      const newSize = {\n        width: entry.contentRect.width,\n        height: entry.contentRect.height\n      };\n      if (newSize.width === lastSize.width && newSize.height === lastSize.height) {\n        return;\n      }\n      apiRef.current.publishEvent('resize', newSize);\n      lastSize = newSize;\n    });\n    observer.observe(node);\n    if (reactMajor >= 19) {\n      return () => {\n        mainRef.current = null;\n        observer.disconnect();\n      };\n    }\n    return undefined;\n  }, [apiRef, mainRef]);\n\n  /*\n   * Scroll context logic\n   * ====================\n   * We only render the cells contained in the `renderContext`. However, when the user starts scrolling the grid\n   * in a direction, we want to render as many cells as possible in that direction, as to avoid presenting white\n   * areas if the user scrolls too fast/far and the viewport ends up in a region we haven't rendered yet. To render\n   * more cells, we store some offsets to add to the viewport in `scrollCache.buffer`. Those offsets make the render\n   * context wider in the direction the user is going, but also makes the buffer around the viewport `0` for the\n   * dimension (horizontal or vertical) in which the user is not scrolling. So if the normal viewport is 8 columns\n   * wide, with a 1 column buffer (10 columns total), then we want it to be exactly 8 columns wide during vertical\n   * scroll.\n   * However, we don't want the rows in the old context to re-render from e.g. 10 columns to 8 columns, because that's\n   * work that's not necessary. Thus we store the context at the start of the scroll in `frozenContext`, and the rows\n   * that are part of this old context will keep their same render context as to avoid re-rendering.\n   */\n  const scrollPosition = React.useRef(EMPTY_SCROLL_POSITION);\n  const previousContextScrollPosition = React.useRef(EMPTY_SCROLL_POSITION);\n  const previousRowContext = React.useRef(EMPTY_RENDER_CONTEXT);\n  const renderContext = useGridSelector(apiRef, gridRenderContextSelector);\n  const scrollTimeout = useTimeout();\n  const frozenContext = React.useRef(undefined);\n  const scrollCache = useLazyRef(() => createScrollCache(isRtl, rootProps.rowBufferPx, rootProps.columnBufferPx, dimensions.rowHeight * 15, MINIMUM_COLUMN_WIDTH * 6)).current;\n  const focusedCell = {\n    rowIndex: React.useMemo(() => cellFocus ? currentPage.rows.findIndex(row => row.id === cellFocus.id) : -1, [cellFocus, currentPage.rows]),\n    columnIndex: React.useMemo(() => cellFocus ? visibleColumns.findIndex(column => column.field === cellFocus.field) : -1, [cellFocus, visibleColumns])\n  };\n  const updateRenderContext = React.useCallback(nextRenderContext => {\n    if (areRenderContextsEqual(nextRenderContext, apiRef.current.state.virtualization.renderContext)) {\n      return;\n    }\n    const didRowsIntervalChange = nextRenderContext.firstRowIndex !== previousRowContext.current.firstRowIndex || nextRenderContext.lastRowIndex !== previousRowContext.current.lastRowIndex;\n    apiRef.current.setState(state => {\n      return _extends({}, state, {\n        virtualization: _extends({}, state.virtualization, {\n          renderContext: nextRenderContext\n        })\n      });\n    });\n\n    // The lazy-loading hook is listening to `renderedRowsIntervalChange`,\n    // but only does something if the dimensions are also available.\n    // So we wait until we have valid dimensions before publishing the first event.\n    if (dimensions.isReady && didRowsIntervalChange) {\n      previousRowContext.current = nextRenderContext;\n      apiRef.current.publishEvent('renderedRowsIntervalChange', nextRenderContext);\n    }\n    previousContextScrollPosition.current = scrollPosition.current;\n  }, [apiRef, dimensions.isReady]);\n  const triggerUpdateRenderContext = useEventCallback(() => {\n    const scroller = scrollerRef.current;\n    if (!scroller) {\n      return undefined;\n    }\n    const newScroll = {\n      top: scroller.scrollTop,\n      left: scroller.scrollLeft\n    };\n    const dx = newScroll.left - scrollPosition.current.left;\n    const dy = newScroll.top - scrollPosition.current.top;\n    const isScrolling = dx !== 0 || dy !== 0;\n    scrollPosition.current = newScroll;\n    const direction = isScrolling ? directionForDelta(dx, dy) : ScrollDirection.NONE;\n\n    // Since previous render, we have scrolled...\n    const rowScroll = Math.abs(scrollPosition.current.top - previousContextScrollPosition.current.top);\n    const columnScroll = Math.abs(scrollPosition.current.left - previousContextScrollPosition.current.left);\n\n    // PERF: use the computed minimum column width instead of a static one\n    const didCrossThreshold = rowScroll >= dimensions.rowHeight || columnScroll >= MINIMUM_COLUMN_WIDTH;\n    const didChangeDirection = scrollCache.direction !== direction;\n    const shouldUpdate = didCrossThreshold || didChangeDirection;\n    if (!shouldUpdate) {\n      return renderContext;\n    }\n\n    // Render a new context\n\n    if (didChangeDirection) {\n      switch (direction) {\n        case ScrollDirection.NONE:\n        case ScrollDirection.LEFT:\n        case ScrollDirection.RIGHT:\n          frozenContext.current = undefined;\n          break;\n        default:\n          frozenContext.current = renderContext;\n          break;\n      }\n    }\n    scrollCache.direction = direction;\n    scrollCache.buffer = bufferForDirection(isRtl, direction, rootProps.rowBufferPx, rootProps.columnBufferPx, dimensions.rowHeight * 15, MINIMUM_COLUMN_WIDTH * 6);\n    const inputs = inputsSelector(apiRef, rootProps, enabledForRows, enabledForColumns);\n    const nextRenderContext = computeRenderContext(inputs, scrollPosition.current, scrollCache);\n\n    // Prevents batching render context changes\n    ReactDOM.flushSync(() => {\n      updateRenderContext(nextRenderContext);\n    });\n    scrollTimeout.start(1000, triggerUpdateRenderContext);\n    return nextRenderContext;\n  });\n  const forceUpdateRenderContext = () => {\n    const inputs = inputsSelector(apiRef, rootProps, enabledForRows, enabledForColumns);\n    const nextRenderContext = computeRenderContext(inputs, scrollPosition.current, scrollCache);\n    // Reset the frozen context when the render context changes, see the illustration in https://github.com/mui/mui-x/pull/12353\n    frozenContext.current = undefined;\n    updateRenderContext(nextRenderContext);\n  };\n  const handleScroll = useEventCallback(event => {\n    const {\n      scrollTop,\n      scrollLeft\n    } = event.currentTarget;\n\n    // On iOS and macOS, negative offsets are possible when swiping past the start\n    if (scrollTop < 0) {\n      return;\n    }\n    if (!isRtl) {\n      if (scrollLeft < 0) {\n        return;\n      }\n    }\n    if (isRtl) {\n      if (scrollLeft > 0) {\n        return;\n      }\n    }\n    const nextRenderContext = triggerUpdateRenderContext();\n    apiRef.current.publishEvent('scrollPositionChange', {\n      top: scrollTop,\n      left: scrollLeft,\n      renderContext: nextRenderContext\n    });\n  });\n  const handleWheel = useEventCallback(event => {\n    apiRef.current.publishEvent('virtualScrollerWheel', {}, event);\n  });\n  const handleTouchMove = useEventCallback(event => {\n    apiRef.current.publishEvent('virtualScrollerTouchMove', {}, event);\n  });\n  const getRows = (params = {}) => {\n    if (!params.rows && !currentPage.range) {\n      return [];\n    }\n    const baseRenderContext = params.renderContext ?? renderContext;\n    const isLastSection = !hasBottomPinnedRows && params.position === undefined || hasBottomPinnedRows && params.position === 'bottom';\n    const isPinnedSection = params.position !== undefined;\n    let rowIndexOffset;\n    // FIXME: Why is the switch check exhaustiveness not validated with typescript-eslint?\n    // eslint-disable-next-line default-case\n    switch (params.position) {\n      case 'top':\n        rowIndexOffset = 0;\n        break;\n      case 'bottom':\n        rowIndexOffset = pinnedRows.top.length + currentPage.rows.length;\n        break;\n      case undefined:\n        rowIndexOffset = pinnedRows.top.length;\n        break;\n    }\n    const rowModels = params.rows ?? currentPage.rows;\n    const firstRowToRender = baseRenderContext.firstRowIndex;\n    const lastRowToRender = Math.min(baseRenderContext.lastRowIndex, rowModels.length);\n    const rowIndexes = params.rows ? range(0, params.rows.length) : range(firstRowToRender, lastRowToRender);\n    let virtualRowIndex = -1;\n    if (!isPinnedSection && focusedCell.rowIndex !== -1) {\n      if (focusedCell.rowIndex < firstRowToRender) {\n        virtualRowIndex = focusedCell.rowIndex;\n        rowIndexes.unshift(virtualRowIndex);\n      }\n      if (focusedCell.rowIndex >= lastRowToRender) {\n        virtualRowIndex = focusedCell.rowIndex;\n        rowIndexes.push(virtualRowIndex);\n      }\n    }\n    const rows = [];\n    const rowProps = rootProps.slotProps?.row;\n    const columnPositions = gridColumnPositionsSelector(apiRef);\n    rowIndexes.forEach(rowIndexInPage => {\n      const {\n        id,\n        model\n      } = rowModels[rowIndexInPage];\n      const rowIndex = (currentPage?.range?.firstRowIndex || 0) + rowIndexOffset + rowIndexInPage;\n\n      // NOTE: This is an expensive feature, the colSpan code could be optimized.\n      if (hasColSpan) {\n        const minFirstColumn = pinnedColumns.left.length;\n        const maxLastColumn = visibleColumns.length - pinnedColumns.right.length;\n        apiRef.current.calculateColSpan({\n          rowId: id,\n          minFirstColumn,\n          maxLastColumn,\n          columns: visibleColumns\n        });\n        if (pinnedColumns.left.length > 0) {\n          apiRef.current.calculateColSpan({\n            rowId: id,\n            minFirstColumn: 0,\n            maxLastColumn: pinnedColumns.left.length,\n            columns: visibleColumns\n          });\n        }\n        if (pinnedColumns.right.length > 0) {\n          apiRef.current.calculateColSpan({\n            rowId: id,\n            minFirstColumn: visibleColumns.length - pinnedColumns.right.length,\n            maxLastColumn: visibleColumns.length,\n            columns: visibleColumns\n          });\n        }\n      }\n      const hasFocus = cellFocus?.id === id;\n      const baseRowHeight = !apiRef.current.rowHasAutoHeight(id) ? apiRef.current.unstable_getRowHeight(id) : 'auto';\n      let isSelected;\n      if (selectedRowsLookup[id] == null) {\n        isSelected = false;\n      } else {\n        isSelected = apiRef.current.isRowSelectable(id);\n      }\n      let isFirstVisible = false;\n      if (params.position === undefined) {\n        isFirstVisible = rowIndexInPage === 0;\n      }\n      let isLastVisible = false;\n      const isLastVisibleInSection = rowIndexInPage === rowModels.length - 1;\n      if (isLastSection) {\n        if (!isPinnedSection) {\n          const lastIndex = currentPage.rows.length - 1;\n          const isLastVisibleRowIndex = rowIndexInPage === lastIndex;\n          if (isLastVisibleRowIndex) {\n            isLastVisible = true;\n          }\n        } else {\n          isLastVisible = isLastVisibleInSection;\n        }\n      }\n      const isVirtualRow = rowIndexInPage === virtualRowIndex;\n      const isNotVisible = isVirtualRow;\n      let tabbableCell = null;\n      if (cellTabIndex !== null && cellTabIndex.id === id) {\n        const cellParams = apiRef.current.getCellParams(id, cellTabIndex.field);\n        tabbableCell = cellParams.cellMode === 'view' ? cellTabIndex.field : null;\n      }\n      let currentRenderContext = baseRenderContext;\n      if (!isPinnedSection && frozenContext.current && rowIndexInPage >= frozenContext.current.firstRowIndex && rowIndexInPage < frozenContext.current.lastRowIndex) {\n        currentRenderContext = frozenContext.current;\n      }\n      const offsetLeft = computeOffsetLeft(columnPositions, currentRenderContext, pinnedColumns.left.length);\n      const showBottomBorder = isLastVisibleInSection && params.position === 'top';\n      rows.push(/*#__PURE__*/_jsx(rootProps.slots.row, _extends({\n        row: model,\n        rowId: id,\n        index: rowIndex,\n        selected: isSelected,\n        offsetTop: params.rows ? undefined : rowsMeta.positions[rowIndexInPage],\n        offsetLeft: offsetLeft,\n        dimensions: dimensions,\n        rowHeight: baseRowHeight,\n        tabbableCell: tabbableCell,\n        pinnedColumns: pinnedColumns,\n        visibleColumns: visibleColumns,\n        renderContext: currentRenderContext,\n        focusedColumnIndex: hasFocus ? focusedCell.columnIndex : undefined,\n        isFirstVisible: isFirstVisible,\n        isLastVisible: isLastVisible,\n        isNotVisible: isNotVisible,\n        showBottomBorder: showBottomBorder\n      }, rowProps), id));\n      if (isNotVisible) {\n        return;\n      }\n      const panel = panels.get(id);\n      if (panel) {\n        rows.push(panel);\n      }\n      if (params.position === undefined && isLastVisibleInSection) {\n        rows.push(apiRef.current.getInfiniteLoadingTriggerElement?.({\n          lastRowId: id\n        }));\n      }\n    });\n    return rows;\n  };\n  const needsHorizontalScrollbar = outerSize.width && columnsTotalWidth > outerSize.width;\n  const scrollerStyle = React.useMemo(() => ({\n    overflowX: !needsHorizontalScrollbar || listView ? 'hidden' : undefined,\n    overflowY: rootProps.autoHeight ? 'hidden' : undefined\n  }), [needsHorizontalScrollbar, rootProps.autoHeight, listView]);\n  const contentSize = React.useMemo(() => {\n    const size = {\n      width: needsHorizontalScrollbar ? columnsTotalWidth : 'auto',\n      flexBasis: contentHeight,\n      flexShrink: 0\n    };\n    if (size.flexBasis === 0) {\n      size.flexBasis = minimalContentHeight; // Give room to show the overlay when there no rows.\n    }\n    return size;\n  }, [columnsTotalWidth, contentHeight, needsHorizontalScrollbar]);\n  React.useEffect(() => {\n    apiRef.current.publishEvent('virtualScrollerContentSizeChange');\n  }, [apiRef, contentSize]);\n  useEnhancedEffect(() => {\n    // TODO a scroll reset should not be necessary\n    if (enabledForColumns) {\n      scrollerRef.current.scrollLeft = 0;\n    }\n    if (enabledForRows) {\n      scrollerRef.current.scrollTop = 0;\n    }\n  }, [enabledForColumns, enabledForRows, gridRootRef, scrollerRef]);\n  useEnhancedEffect(() => {\n    if (listView) {\n      scrollerRef.current.scrollLeft = 0;\n    }\n  }, [listView, scrollerRef]);\n  useRunOnce(outerSize.width !== 0, () => {\n    const inputs = inputsSelector(apiRef, rootProps, enabledForRows, enabledForColumns);\n    const initialRenderContext = computeRenderContext(inputs, scrollPosition.current, scrollCache);\n    updateRenderContext(initialRenderContext);\n    apiRef.current.publishEvent('scrollPositionChange', {\n      top: scrollPosition.current.top,\n      left: scrollPosition.current.left,\n      renderContext: initialRenderContext\n    });\n  });\n  apiRef.current.register('private', {\n    updateRenderContext: forceUpdateRenderContext\n  });\n  useGridApiEventHandler(apiRef, 'columnsChange', forceUpdateRenderContext);\n  useGridApiEventHandler(apiRef, 'filteredRowsSet', forceUpdateRenderContext);\n  useGridApiEventHandler(apiRef, 'rowExpansionChange', forceUpdateRenderContext);\n  return {\n    renderContext,\n    setPanels,\n    getRows,\n    getContainerProps: () => ({\n      ref: mainRefCallback\n    }),\n    getScrollerProps: () => ({\n      ref: scrollerRef,\n      onScroll: handleScroll,\n      onWheel: handleWheel,\n      onTouchMove: handleTouchMove,\n      style: scrollerStyle,\n      role: 'presentation',\n      // `tabIndex` shouldn't be used along role=presentation, but it fixes a Firefox bug\n      // https://github.com/mui/mui-x/pull/13891#discussion_r1683416024\n      tabIndex: platform.isFirefox ? -1 : undefined\n    }),\n    getContentProps: () => ({\n      style: contentSize,\n      role: 'presentation'\n    }),\n    getRenderZoneProps: () => ({\n      role: 'rowgroup'\n    }),\n    getScrollbarVerticalProps: () => ({\n      ref: scrollbarVerticalRef,\n      role: 'presentation'\n    }),\n    getScrollbarHorizontalProps: () => ({\n      ref: scrollbarHorizontalRef,\n      role: 'presentation'\n    })\n  };\n};\nfunction inputsSelector(apiRef, rootProps, enabledForRows, enabledForColumns) {\n  const dimensions = gridDimensionsSelector(apiRef.current.state);\n  const currentPage = getVisibleRows(apiRef, rootProps);\n  const visibleColumns = rootProps.unstable_listView ? [gridListColumnSelector(apiRef.current.state)] : gridVisibleColumnDefinitionsSelector(apiRef);\n  const hiddenCellsOriginMap = gridRowSpanningHiddenCellsOriginMapSelector(apiRef);\n  const lastRowId = apiRef.current.state.rows.dataRowIds.at(-1);\n  const lastColumn = visibleColumns.at(-1);\n  return {\n    enabledForRows,\n    enabledForColumns,\n    apiRef,\n    autoHeight: rootProps.autoHeight,\n    rowBufferPx: rootProps.rowBufferPx,\n    columnBufferPx: rootProps.columnBufferPx,\n    leftPinnedWidth: dimensions.leftPinnedWidth,\n    columnsTotalWidth: dimensions.columnsTotalWidth,\n    viewportInnerWidth: dimensions.viewportInnerSize.width,\n    viewportInnerHeight: dimensions.viewportInnerSize.height,\n    lastRowHeight: lastRowId !== undefined ? apiRef.current.unstable_getRowHeight(lastRowId) : 0,\n    lastColumnWidth: lastColumn?.computedWidth ?? 0,\n    rowsMeta: gridRowsMetaSelector(apiRef.current.state),\n    columnPositions: gridColumnPositionsSelector(apiRef),\n    rows: currentPage.rows,\n    range: currentPage.range,\n    pinnedColumns: gridVisiblePinnedColumnDefinitionsSelector(apiRef),\n    visibleColumns,\n    hiddenCellsOriginMap,\n    listView: rootProps.unstable_listView ?? false,\n    virtualizeColumnsWithAutoRowHeight: rootProps.virtualizeColumnsWithAutoRowHeight\n  };\n}\nfunction computeRenderContext(inputs, scrollPosition, scrollCache) {\n  const renderContext = {\n    firstRowIndex: 0,\n    lastRowIndex: inputs.rows.length,\n    firstColumnIndex: 0,\n    lastColumnIndex: inputs.visibleColumns.length\n  };\n  const {\n    top,\n    left\n  } = scrollPosition;\n  const realLeft = Math.abs(left) + inputs.leftPinnedWidth;\n  if (inputs.enabledForRows) {\n    // Clamp the value because the search may return an index out of bounds.\n    // In the last index, this is not needed because Array.slice doesn't include it.\n    let firstRowIndex = Math.min(getNearestIndexToRender(inputs, top, {\n      atStart: true,\n      lastPosition: inputs.rowsMeta.positions[inputs.rowsMeta.positions.length - 1] + inputs.lastRowHeight\n    }), inputs.rowsMeta.positions.length - 1);\n\n    // If any of the cells in the `firstRowIndex` is hidden due to an extended row span,\n    // Make sure the row from where the rowSpan is originated is visible.\n    const rowSpanHiddenCellOrigin = inputs.hiddenCellsOriginMap[firstRowIndex];\n    if (rowSpanHiddenCellOrigin) {\n      const minSpannedRowIndex = Math.min(...Object.values(rowSpanHiddenCellOrigin));\n      firstRowIndex = Math.min(firstRowIndex, minSpannedRowIndex);\n    }\n    const lastRowIndex = inputs.autoHeight ? firstRowIndex + inputs.rows.length : getNearestIndexToRender(inputs, top + inputs.viewportInnerHeight);\n    renderContext.firstRowIndex = firstRowIndex;\n    renderContext.lastRowIndex = lastRowIndex;\n  }\n  if (inputs.enabledForColumns) {\n    let firstColumnIndex = 0;\n    let lastColumnIndex = inputs.columnPositions.length;\n    let hasRowWithAutoHeight = false;\n    const [firstRowToRender, lastRowToRender] = getIndexesToRender({\n      firstIndex: renderContext.firstRowIndex,\n      lastIndex: renderContext.lastRowIndex,\n      minFirstIndex: 0,\n      maxLastIndex: inputs.rows.length,\n      bufferBefore: scrollCache.buffer.rowBefore,\n      bufferAfter: scrollCache.buffer.rowAfter,\n      positions: inputs.rowsMeta.positions,\n      lastSize: inputs.lastRowHeight\n    });\n    if (!inputs.virtualizeColumnsWithAutoRowHeight) {\n      for (let i = firstRowToRender; i < lastRowToRender && !hasRowWithAutoHeight; i += 1) {\n        const row = inputs.rows[i];\n        hasRowWithAutoHeight = inputs.apiRef.current.rowHasAutoHeight(row.id);\n      }\n    }\n    if (!hasRowWithAutoHeight || inputs.virtualizeColumnsWithAutoRowHeight) {\n      firstColumnIndex = binarySearch(realLeft, inputs.columnPositions, {\n        atStart: true,\n        lastPosition: inputs.columnsTotalWidth\n      });\n      lastColumnIndex = binarySearch(realLeft + inputs.viewportInnerWidth, inputs.columnPositions);\n    }\n    renderContext.firstColumnIndex = firstColumnIndex;\n    renderContext.lastColumnIndex = lastColumnIndex;\n  }\n  const actualRenderContext = deriveRenderContext(inputs, renderContext, scrollCache);\n  return actualRenderContext;\n}\nfunction getNearestIndexToRender(inputs, offset, options) {\n  const lastMeasuredIndexRelativeToAllRows = inputs.apiRef.current.getLastMeasuredRowIndex();\n  let allRowsMeasured = lastMeasuredIndexRelativeToAllRows === Infinity;\n  if (inputs.range?.lastRowIndex && !allRowsMeasured) {\n    // Check if all rows in this page are already measured\n    allRowsMeasured = lastMeasuredIndexRelativeToAllRows >= inputs.range.lastRowIndex;\n  }\n  const lastMeasuredIndexRelativeToCurrentPage = clamp(lastMeasuredIndexRelativeToAllRows - (inputs.range?.firstRowIndex || 0), 0, inputs.rowsMeta.positions.length);\n  if (allRowsMeasured || inputs.rowsMeta.positions[lastMeasuredIndexRelativeToCurrentPage] >= offset) {\n    // If all rows were measured (when no row has \"auto\" as height) or all rows before the offset\n    // were measured, then use a binary search because it's faster.\n    return binarySearch(offset, inputs.rowsMeta.positions, options);\n  }\n\n  // Otherwise, use an exponential search.\n  // If rows have \"auto\" as height, their positions will be based on estimated heights.\n  // In this case, we can skip several steps until we find a position higher than the offset.\n  // Inspired by https://github.com/bvaughn/react-virtualized/blob/master/source/Grid/utils/CellSizeAndPositionManager.js\n  return exponentialSearch(offset, inputs.rowsMeta.positions, lastMeasuredIndexRelativeToCurrentPage, options);\n}\n\n/**\n * Accepts as input a raw render context (the area visible in the viewport) and adds\n * computes the actual render context based on pinned elements, buffer dimensions and\n * spanning.\n */\nfunction deriveRenderContext(inputs, nextRenderContext, scrollCache) {\n  const [firstRowToRender, lastRowToRender] = getIndexesToRender({\n    firstIndex: nextRenderContext.firstRowIndex,\n    lastIndex: nextRenderContext.lastRowIndex,\n    minFirstIndex: 0,\n    maxLastIndex: inputs.rows.length,\n    bufferBefore: scrollCache.buffer.rowBefore,\n    bufferAfter: scrollCache.buffer.rowAfter,\n    positions: inputs.rowsMeta.positions,\n    lastSize: inputs.lastRowHeight\n  });\n  const [initialFirstColumnToRender, lastColumnToRender] = getIndexesToRender({\n    firstIndex: nextRenderContext.firstColumnIndex,\n    lastIndex: nextRenderContext.lastColumnIndex,\n    minFirstIndex: inputs.pinnedColumns.left.length,\n    maxLastIndex: inputs.visibleColumns.length - inputs.pinnedColumns.right.length,\n    bufferBefore: scrollCache.buffer.columnBefore,\n    bufferAfter: scrollCache.buffer.columnAfter,\n    positions: inputs.columnPositions,\n    lastSize: inputs.lastColumnWidth\n  });\n  const firstColumnToRender = getFirstNonSpannedColumnToRender({\n    firstColumnToRender: initialFirstColumnToRender,\n    apiRef: inputs.apiRef,\n    firstRowToRender,\n    lastRowToRender,\n    visibleRows: inputs.rows\n  });\n  return {\n    firstRowIndex: firstRowToRender,\n    lastRowIndex: lastRowToRender,\n    firstColumnIndex: firstColumnToRender,\n    lastColumnIndex: lastColumnToRender\n  };\n}\n/**\n * Use binary search to avoid looping through all possible positions.\n * The `options.atStart` provides the possibility to match for the first element that\n * intersects the screen, even if said element's start position is before `offset`. In\n * other words, we search for `offset + width`.\n */\nfunction binarySearch(offset, positions, options = undefined, sliceStart = 0, sliceEnd = positions.length) {\n  if (positions.length <= 0) {\n    return -1;\n  }\n  if (sliceStart >= sliceEnd) {\n    return sliceStart;\n  }\n  const pivot = sliceStart + Math.floor((sliceEnd - sliceStart) / 2);\n  const position = positions[pivot];\n  let isBefore;\n  if (options?.atStart) {\n    const width = (pivot === positions.length - 1 ? options.lastPosition : positions[pivot + 1]) - position;\n    isBefore = offset - width < position;\n  } else {\n    isBefore = offset <= position;\n  }\n  return isBefore ? binarySearch(offset, positions, options, sliceStart, pivot) : binarySearch(offset, positions, options, pivot + 1, sliceEnd);\n}\nfunction exponentialSearch(offset, positions, index, options = undefined) {\n  let interval = 1;\n  while (index < positions.length && Math.abs(positions[index]) < offset) {\n    index += interval;\n    interval *= 2;\n  }\n  return binarySearch(offset, positions, options, Math.floor(index / 2), Math.min(index, positions.length));\n}\nfunction getIndexesToRender({\n  firstIndex,\n  lastIndex,\n  bufferBefore,\n  bufferAfter,\n  minFirstIndex,\n  maxLastIndex,\n  positions,\n  lastSize\n}) {\n  const firstPosition = positions[firstIndex] - bufferBefore;\n  const lastPosition = positions[lastIndex] + bufferAfter;\n  const firstIndexPadded = binarySearch(firstPosition, positions, {\n    atStart: true,\n    lastPosition: positions[positions.length - 1] + lastSize\n  });\n  const lastIndexPadded = binarySearch(lastPosition, positions);\n  return [clamp(firstIndexPadded, minFirstIndex, maxLastIndex), clamp(lastIndexPadded, minFirstIndex, maxLastIndex)];\n}\nexport function areRenderContextsEqual(context1, context2) {\n  if (context1 === context2) {\n    return true;\n  }\n  return context1.firstRowIndex === context2.firstRowIndex && context1.lastRowIndex === context2.lastRowIndex && context1.firstColumnIndex === context2.firstColumnIndex && context1.lastColumnIndex === context2.lastColumnIndex;\n}\nexport function computeOffsetLeft(columnPositions, renderContext, pinnedLeftLength) {\n  const left = (columnPositions[renderContext.firstColumnIndex] ?? 0) - (columnPositions[pinnedLeftLength] ?? 0);\n  return Math.abs(left);\n}\nfunction directionForDelta(dx, dy) {\n  if (dx === 0 && dy === 0) {\n    return ScrollDirection.NONE;\n  }\n  /* eslint-disable */\n  if (Math.abs(dy) >= Math.abs(dx)) {\n    if (dy > 0) {\n      return ScrollDirection.DOWN;\n    } else {\n      return ScrollDirection.UP;\n    }\n  } else {\n    if (dx > 0) {\n      return ScrollDirection.RIGHT;\n    } else {\n      return ScrollDirection.LEFT;\n    }\n  }\n  /* eslint-enable */\n}\nfunction bufferForDirection(isRtl, direction, rowBufferPx, columnBufferPx, verticalBuffer, horizontalBuffer) {\n  if (isRtl) {\n    switch (direction) {\n      case ScrollDirection.LEFT:\n        direction = ScrollDirection.RIGHT;\n        break;\n      case ScrollDirection.RIGHT:\n        direction = ScrollDirection.LEFT;\n        break;\n      default:\n    }\n  }\n  switch (direction) {\n    case ScrollDirection.NONE:\n      return {\n        rowAfter: rowBufferPx,\n        rowBefore: rowBufferPx,\n        columnAfter: columnBufferPx,\n        columnBefore: columnBufferPx\n      };\n    case ScrollDirection.LEFT:\n      return {\n        rowAfter: 0,\n        rowBefore: 0,\n        columnAfter: 0,\n        columnBefore: horizontalBuffer\n      };\n    case ScrollDirection.RIGHT:\n      return {\n        rowAfter: 0,\n        rowBefore: 0,\n        columnAfter: horizontalBuffer,\n        columnBefore: 0\n      };\n    case ScrollDirection.UP:\n      return {\n        rowAfter: 0,\n        rowBefore: verticalBuffer,\n        columnAfter: 0,\n        columnBefore: 0\n      };\n    case ScrollDirection.DOWN:\n      return {\n        rowAfter: verticalBuffer,\n        rowBefore: 0,\n        columnAfter: 0,\n        columnBefore: 0\n      };\n    default:\n      // eslint unable to figure out enum exhaustiveness\n      throw new Error('unreachable');\n  }\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}